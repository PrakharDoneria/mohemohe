---
title: Oops Java Lab
description: Object Oriented Programming with Java lab
publishedDate: 2024-05-08
updatedDate: 2024-06-03
published: true
tags: ["Java", "aktu", "b-tech", "CSE", "lab"]

---
## Quick Links

- [Experiment 1](#experiment-1)
- [Experiment 2](#experiment-2)
- [Experiment 3](#experiment-3)
- [Experiment 4](#experiment-4)
- [Experiment 5](#experiment-5)
- [Experiment 6](#experiment-6)
- [Experiment 7](#experiment-7)
- [Experiment 8](#experiment-8)


<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-1" >**Experiment 1**</Callout>
<Callout type="knowing">**Objective:** Installation and use Java compiler and eclipse platform to write and execute java program. </Callout>

**Theory:**
- Java is a high-level, object-oriented programming language developed by Sun Microsystems *(now owned by Oracle Corporation)*. It was first released in 1995, designed to be platform-independent. *i.e.* Java programs can run on any device or operating system that has a **Java Virtual Machine** (**JVM**) installed.
- Java is widely used for developing a variety of applications, including web applications, mobile apps *(Android applications are widely built using Java)*, enterprise software, and more. Java has a vast ecosystem of libraries, framework, and tools that furture ecnhance its capabilities and productivity for developers.

**Installation of Java Development Kit (JDK):**
- **Java Development Kit** (**JDK**) is essential for Java development as it includes the **Java Runtime Environment** (**JRE**), compiler, debugger and other tools necessary for building Java applications.

- **Visit:** Official Oracle website or OpenJDK website to download the latest version of JDK.
Choose the appropriate JDK version for your operating system *(Windows, macOS, Linux)*.


- Run the downloaded JDK installer executable file. Ensure that the JDK bin directory is added to the system PATH environment variable.

- Open a command prompt (Windows) or terminal (macOS, Linux). Type `java -version` and press Enter to verify the JDK installation.

```shell title="Terminal"
java -version
openjdk version "11.0.16.1" 2022-08-12 LTS
OpenJDK Runtime Environment Microsoft-40648 (build 11.0.16.1+1-LTS)
OpenJDK 64-Bit Server VM Microsoft-40648 (build 11.0.16.1+1-LTS, mixed mode)
```

**Installation of Eclipse IDE:**
- **Eclipse** is a powerfull IDE widely used by Java developers for coding, debugging, and testing Java applications.

- **Visit:** Eclipse Foundation website and navigate to the downloads section. Run the downloaded Eclipse installer executable file and complete the installation process.

**Installation of Java with Terminal in Linux:**
- For installing **JDK**

```shell title="Terminal"
sudo apt-get install default-jdk
java -version
```

- For installing **Eclipse**
```shell title="Terminal"
sudo snap install eclipse --clasic
```

- Instructions for creating and running it both in **Eclipse** and using the **command line** (**cmd**).

Here's a simple Java program that checks whether a given number is prime or not. 
```java showLineNumbers title="Prime.java"
public class Prime {
	public static void main(String[] args) {
		int num = 29; // Change this number to check prime or not for a different number
		boolean prime = true;
		if (num <= 1) {
			prime = false;
		} else {
			for (int i = 2; i <= num / 2; i++) {
				if (num % i == 0) {
					prime = false;
				}
			}
		}
		if (prime == true) {
			System.out.println(num + " is a prime no.");
		} else {
			System.out.println(num + " is not a prime no.");
		}
	}
}
```


**Running in Eclipse:**
- Open Eclipse and create a new Java project.
- Inside the project, create a new Java class named `Prime`.
- Write the provided Java code into the `Prime.java` file.
- Save the file.
- Right-click on the `Prime.java` file in the Package Explorer.
- Select "**Run As**" -> "**Java Application**".
- Now, the output in the console.

```terminal title="Terminal"
29 is a prime no.
```

Here's a simple Java program that calculates the factorial of a given number. 

```java showLineNumbers title="Factorial.java"
public class Factorial {
  public static void main(String[] args) {
    int number = 5; // Change this number to calculate factorial for a different number
    long factorial = calculateFactorial(number);
    System.out.println("Factorial of " + number + " is: " + factorial);
  }

  public static long calculateFactorial(int n) {
    if (n == 0 || n == 1) {
      return 1;
    } else {
      return n * calculateFactorial(n - 1);
    }
  }
}
```
**Running using CMD:**
- Save the provided Java code into a file named `Factorial.java`.
- Open a command prompt (**CMD**).
- Navigate to the directory where `Factorial.java` is saved using the `cd` command.
- Compile the Java file by typing `javac Factorial.java` and pressing Enter.
- Once compiled successfully, run the program by typing `java Factorial` and pressing Enter.
- You should see the output in the **command prompt**.

```terminal title="Terminal"
Factorial of 5 is: 120
```

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-2" >**Experiment 2**</Callout>
<Callout type="knowing">**Objective:** Creating simple Calculator java programs using command line arguments. </Callout>

**Theory:**
- **Command-Line Arguments:** Command-line arguments are parameters passed to a program when it is executed. In Java, these arguments are stored in the `args` parameter of the `main` method.
- **Parsing:** Parsing is the process of converting data from one format to another. Here, we parse string arguments into numerical values using methods like `Double.parseDouble()`.
- **Conditional Statements:** The program uses conditional statements (`if` and `switch`) to validate input, handle errors, and perform different operations based on the operator.
- **Arithmetic Operations:** Arithmetic operations such as *addition*, *subtraction*, *multiplication*, and *division* are fundamental mathematical concepts. In this program, they are implemented using Java operators (`+`, `-`, `*`, `/`).
- **Error Handling:** Error handling is crucial for robust software. In this program, we handle division by zero by checking for this condition explicitly

```java showLineNumbers title="Calculator.java"
public class Calculator {
  public static void main(String[] args) {
    
    if (args.length != 3) {
      System.out.println("Usage: java Calculator num1 operator num2");
      return;
    }

    double num1 = Double.parseDouble(args[0]);
    String operator = args[1];
    double num2 = Double.parseDouble(args[2]);
    double result = 0.0;

    switch (operator) {
      case "+":
        result = num1 + num2;
        break;

      case "-":
        result = num1 - num2;
        break;

      case "*":
        result = num1 * num2;
        break;

      case "/":
        if (num2 != 0) {
          result = num1 / num2;
        } else {
          System.out.println("Error: Division by zero");
          return;
        } break;
      default:
        System.out.println("Error: Invalid operator");
        return;
    }
    System.out.println("Result: " + result);
  }
}
```

To compile this code, open your command prompt or terminal, navigate to the directory where you saved `Calculator.java`, and run as:

```shell title="Terminal"
javac Calculator.java
```
Once compiled successfully, run the program with command-line arguments as:

```shell title="Terminal"
java Calculator 5 + 3
```

```terminal title="Output"
Result: 8.0
```
Similarly, we can perform other operations like subtraction, multiplication and division:
```shell title="Terminal"
java Calculator 10 - 4
java Calculator 6 * 2
java Calculator 8 / 2
```
          
<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-3" >**Experiment 3**</Callout>
<Callout type="knowing">**Objective:** Understand OOP concepts (Abstraction) and basics of Java programming. </Callout>

**Theory:**
- A class is a blueprint or template for creating objects. It defines the properties (fields) and behaviors (methods) that objects of that type will have.
- Abstraction is the process of hiding the implementation details and showing only the essential features of an object. Abstract classes and interfaces are used to achieve abstraction.

```java showLineNumbers title="Abstraction.java"
abstract class Car {
  Car() {
    System.out.println("Car is built. ");
  }
  abstract void drive();

  void gearChange() {
    System.out.println("Gearchanged!!");
  }
}

class Tesla extends Car {
  void drive() {
    System.out.println("Drive Safely");
  }
}

class Abstraction {
  public static void main(String args[]) {
    Car obj = new Tesla();
    obj.drive();
    obj.gearChange();
  }
}
```

```makefile title="Output"
Car is built. 
Drive Safely
Gearchanged!!
``` 

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-4" >**Experiment 4**</Callout>
<Callout type="knowing">**Objective:** Create Java programs using inheritance and polymorphism. </Callout>

**Theory:**<br/>

- **Inheritance** is a mechanism by which a new class (called a subclass or derived class) is created from an existing class (called a superclass or base class). The subclass inherits the properties and behaviors (methods) of the superclass. This allows for code reuse and peromotes the creation of hirerchical relationships between classes.

- **polymorphism** is Java refers to the ability of objects to take on multiple forms. It allows objects of different classes to be treated as objects of a common superclass through a common interface.

There are two types of polymorphism in java-
- Compile-time polymorphism (method **overloading**)
- Runtime polymorphism (method **overriding**)

```java showLineNumbers title="Inheritance.java"
// Superclass
class Animal {
  void eat() {
    System.out.println("I am a omnivorous!! ");
  }
}

// Subclass
class Mammal extends Animal {
  void nature() {
    System.out.println("I am a mammal!! ");
  }
}

class Dog extends Mammal {
  void sound() {
    System.out.println("I bark!! ");
  }
}

class Inheritance {
  public static void main(String args[]) {
    Dog d = new Dog();
    d.eat();
    d.nature();
    d.sound();
  }
}
```

```makefile title="Output"
I am a omnivorous!! 
I am a mammal!!
I bark!!
```


**Compile-time polymorphism** (**Method Overloading**)**:** This occurs when multiple methods in a class have the same name but different parameters.

```java showLineNumbers title="Overloading.java"
class CircleArea {
  double area(double x) {
    return 3.14 * x;
  }
}

class SquareArea {
  int area(int x) {
    return x * x;
  }
}

class RectangleArea {
  int area(int x, int y) {
    return x * y;
  }
}

class TriangleArea {
  int area(int y, int x) {
    return (y * x) / 2;
  }
}

class Overloading {
  public static void main(String args[]) {
    CircleArea ca = new CircleArea();
    SquareArea sa = new SquareArea();
    RectangleArea ra = new RectangleArea();
    TriangleArea ta = new TriangleArea();

    System.out.println("Circle area = " + ca.area(1));
    System.out.println("Square area = " + sa.area(2));
    System.out.println("Rectangle area = " + ra.area(3, 4));
    System.out.println("Triangle area = " + ta.area(6, 3));
  }
}
```

```makefile title="Output"
Circle area = 3.14
Square area = 4
Rectangle area = 12
Triangle area = 9
```

**Runtime polymorphism** (**Method Overriding**)**:** This occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The subclass method must have the same signature (name and parameters) as the superclass method.

```java showLineNumbers title="Overriding.java"
 class Shape {
  void draw() {
    System.out.println("Mention shape here");
  }

  void numberOfSides() {
    System.out.println("side = 0");
  }
}

class Circle extends Shape {
  void draw() {
    System.out.println("CIRCLE ");
  }

  void numberOfSides() {
    System.out.println("side = 0 ");
  }
}

class Box extends Shape {
  void draw() {
    System.out.println("BOX ");
  }

  void numberOfSides() {
    System.out.println("side= 6");
  }
}

class Triangle extends Shape {
  void draw() {
    System.out.println("TRIANGLE ");
  }

  void numberOfSides() {
    System.out.println("side = 3 ");
  }
}

public class Overriding {
  public static void main(String args[]) {
    Circle c = new Circle();
    c.draw();
    c.numberOfSides();

    Box b = new Box();
    b.draw();
    b.numberOfSides();

    Triangle t = new Triangle();
    t.draw();
    t.numberOfSides();
  }
}
```

```makefile title="Output"
CIRCLE 
side = 0
BOX
side= 6
TRIANGLE
side = 3

```

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-5" >**Experiment 5**</Callout>
<Callout type="knowing">**Objective:** Implement error-handling techniques using exception handling and multithreading. </Callout>
**Theory:**<br/>
Exception handling and multithreading are two crucial aspects of Java programming, especially when it comes to building
 robust and efficient applications.
```java showLineNumbers title="ExceptionDemo.java"
public class ExceptionDemo {
  public static void main(String[] args) {
      // array of size 4.
      int[] arr = new int[4];

      try {
          int i = arr[4];

          // this statement will never execute
          // as exception is raised by above statement
          System.out.println("Inside try block");
      }

      catch (ArrayIndexOutOfBoundsException ex) {
          System.out.println("Exception caught in catch block");
      }
      
      // this will always execute 
      finally {
          System.out.println("finally block executed");
      }
      // rest program will be executed
      System.out.println("Outside try-catch-finally clause");
  }
}
```

```makefile title="Output"
Exception caught in catch block
finally block executed
Outside try-catch-finally clause 
```
- **Throw Exception**
```java showLineNumbers title="ThrowExcepDemo.java"
public class ThrowExcepDemo {
    static void fun() {
        try {
            throw new NullPointerException("demo");
        } catch (NullPointerException e) {
            System.out.println("Caught inside fun().");
            throw e; // rethrowing the exception
        }
    }

    public static void main(String args[]) {
        try {
            fun();
        } catch (NullPointerException e) {
            System.out.println("Caught in main.");
        }
    }
}
```

```makefile title=""
Caught inside fun().
Caught in main.
```
- **Throws Exception**

```java showLineNumbers title="ThrowsExcepDemo.java"
public class ThrowsExecpDemo {
    static void fun() throws IllegalAccessException {
        System.out.println("Inside fun(). ");
        throw new IllegalAccessException("demo");
    }

    public static void main(String args[]) {
        try {
            fun();
        } catch (IllegalAccessException e) {
            System.out.println("caught in main.");
        }
    }
}
```

```makefile title="Output"
Inside fun(). 
caught in main.
```

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-6" >**Experiment 6**</Callout>
<Callout type="knowing">**Objective:** Create java program with the use of java packages. </Callout>

**Theory:**<br/>
A package in Java is a way to organize classes and interfaces into namespaces, facilitating code orgamization and managment.

```java showLineNumbers title="PackageDemo.java"
package MyPack;

// Class to which the above package belongs
public class PackageDemo {

    // Member functions of the class- 'Demo'
    // Method 1 - To show()
    public void show() {

        // Print message
        System.out.println("Hi Everyone");
    }

    // Method 2 - To show()
    public void view() {
        // Print message
        System.out.println("Hello");
    }
}
```
Type this code in terminal for create directory for package. the folder will create same as Package name `MyPack`. In the `MyPack` folder `.class` file will create with the name `.java` file.
```shell title="Terminal"
javac -d . PackageDemo.java
```

```java showLineNumbers title="PackageImportDemo.java"
package MyPack;

import MyPack.*;

// Class to which the package belongs
public class PackageImportDemo {

    // main driver method
    public static void main(String arg[]) {

        // Creating an object of Demo class
        PackageDemo d = new PackageDemo();

        // Calling the functions show() and view()
        // using the object of Demo class
        d.show();
        d.view();
    }
}
```

This line of code will folow rule same as above. If we choose another name of package then `.class` file will create in new folder.
```shell title="Terminal"
javac -d . PackageImportDemo.java
```

For run this code we need to type `package name` with `.class` file name.
```shell title="Terminal"
java MyPack.PackageImportDemo
```

```makefile title="Output"
Hi Everyone
Hello
```


<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-7" >**Experiment 7**</Callout>
<Callout type="knowing">**Objective:** Construct java program using Java Thread. </Callout>

**Theory:**<br/>
Thread in Java represent the execution flow of a program. They enable concurrent execution, allowing multiple tasks to run simultaneously.

**Thread States**<br/>
- **New:** The thread is created but not yet started.
- **Runnable:** The thread is ready to run and waiting for CPU time.
- **Blocked:** The thread is waiting for a monitor lock to enter a synchronized block or method.
- **Waiting:** The thread is waiting indefinitely for another thread to perform a particluar action.
- **Time Waiting:** The thread is waiting for a specified period.
- **Terminated:** The thread has finished execution.

```java title="ThreadStateDemo.java" showLineNumbers
class ThreadTest implements Runnable {
  public void run() {

    // try-catch block
    try {
      // moving thread t2 to the state timed waiting
      Thread.sleep(100);
    } catch (InterruptedException ie) {
      ie.printStackTrace();
    }

    System.out.println(
        "The state of thread t1 while it invoked the method join() on thread t2 -" + 
            ThreadStateDemo.t1.getState());

    // try-catch block
    try {
      Thread.sleep(200);
    } catch (InterruptedException ie) {
      ie.printStackTrace();
    }
  }
}

// ThreadState class implements the interface Runnable
public class ThreadStateDemo implements Runnable {
  public static Thread t1;
  public static ThreadStateDemo obj;

  // main method
  public static void main(String args[]) {
    // creating an object of the class ThreadState
    obj = new ThreadStateDemo();
    t1 = new Thread(obj);

    // thread t1 is spawned
    // The thread t1 is currently in the NEW state.
    System.out.println("The state of thread t1 after spawning it - " + t1.getState());

    // invoking the start() method on
    // the thread t1
    t1.start();

    // thread t1 is moved to the Runnable state
    System.out.println(
        "The state of thread t1 after invoking the method start() on it - " + t1.getState());
  }

  public void run() {
    ThreadTest myObj = new ThreadTest();
    Thread t2 = new Thread(myObj);

    // thread t2 is created and is currently in the NEW state.
    System.out.println("The state of thread t2 after spawning it - " + t2.getState());
    t2.start();

    // thread t2 is moved to the runnable state
    System.out.println(
        "the state of thread t2 after calling the method start() on it - " + t2.getState());

    // try-catch block for the smooth flow of the program
    try {
      // moving the thread t1 to the state timed waiting
      Thread.sleep(200);
    } catch (InterruptedException ie) {
      ie.printStackTrace();
    }

    System.out.println(
        "The state of thread t2 after invoking the method sleep() on it - " + t2.getState());

    // try-catch block for the smooth flow of the program
    try {
      // waiting for thread t2 to complete its execution
      t2.join();
    } catch (InterruptedException ie) {
      ie.printStackTrace();
    }
    System.out.println(
        "The state of thread t2 when it has completed it's execution - " + t2.getState());
  }
}
```

```makefile title="Output"
The state of thread t1 after spawning it - NEW
The state of thread t1 after invoking the method start() on it - RUNNABLE
The state of thread t2 after spawning it - NEW
the state of thread t2 after calling the method start() on it - RUNNABLE
The state of thread t1 while it invoked the method join() on thread t2 -TIMED_WAITING
The state of thread t2 after invoking the method sleep() on it - TIMED_WAITING
The state of thread t2 when it has completed it's execution - TERMINATED
```

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-8" >**Experiment 8**</Callout>
<Callout type="knowing">**Objective:** Construct java program using Java I/O package. </Callout>

**Theory:**

First we need to create the `.txt` file with the name input. Write something in `input.txt` file.
```java title="CopyFile.java" showLineNumbers
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyFile {

   public static void main(String args[]) throws IOException {
      FileInputStream in = null;
      FileOutputStream out = null;

      try {
         in = new FileInputStream("input.txt");
         out = new FileOutputStream("output.txt");

         int c;
         while ((c = in.read()) != -1) {
            out.write(c);
         }
      } finally {
         if (in != null) {
            in.close();
         }
         if (out != null) {
            out.close();
         }
      }
   }
}
```
- The new file will be create and copy all the text which is written in `input.txt`. 

Same Here, First we need to create the `.txt` file with the name input. Write something in `input.txt` file.

```java title="FileCopyDemo.java" showLineNumbers
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class FileCopyDemo {

   public static void main(String args[]) throws IOException {
      FileReader in = null;
      FileWriter out = null;

      try {
         in = new FileReader("input.txt");
         out = new FileWriter("output.txt");

         int c;
         while ((c = in.read()) != -1) {
            out.write(c);
         }
      } finally {
         if (in != null) {
            in.close();
         }
         if (out != null) {
            out.close();
         }
      }
   }
}
```

- The output will be showing as creating or coping all the text from `input.txt` to `output.txt`.

## File Output Stream 
```java title="FileOutputStreamExample.java" showLineNumbers
import java.io.*;

public class FileOutputStreamExample {
      public static void main(String args[]) {
            try {
                  FileOutputStream fout = new FileOutputStream("D:\\testout.txt");
                  fout.write(65);
                  fout.write(66);
                  fout.close();
                  System.out.println("success...");
            } catch (Exception e) {
                  System.out.println(e);
            }
      }
}
```
- The `testout.txt` file will be created in D drive of your computer system storage. In the `testout` file text will appear as **AB**.
```makefile title="Output"
success...
```


```java title="FileOutputStreamExample1.java" showLineNumbers
import java.io.FileOutputStream;

public class FileOutputStreamExample1 {
    public static void main(String args[]) {
        try {
            FileOutputStream fout = new FileOutputStream("testout.txt");
            String s = "Welcome to javaTpoint.";
            byte b[] = s.getBytes();// converting string into byte array
            fout.write(b);
            fout.close();
            System.out.println("success...");
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
```

- The `testout.txt` file will be Created in that folder where we execute this code.
```makefile title="testout.txt"
Welcome to javaTpoint.
```

```makefile title="Output"
success...
```


<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-9" >**Experiment 9**</Callout>
<Callout type="knowing">**Objective:** Create industry oriented application using Spring Framework. </Callout>
