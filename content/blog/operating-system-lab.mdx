---
title: Operating System Lab
description: Operating system lab
publishedDate: 2024-05-05
updatedDate: 2024-06-03
published: true
tags: ["OS", "aktu", "b-tech", "CSE", "lab"]

---
## Quick Links

- [Experiment 1](#experiment-1)
- [Experiment 2](#experiment-2)
- [Experiment 3](#experiment-3)
{/* - [Experiment 4](#experiment-4) */}



<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-1" >**Experiment 1**</Callout>
<Callout type="knowing">**Objective:** Study of hardware and software requirements of differenet operating systems *(Windows 10, UNIX, Linux, Windows XP, and Windows 7/8)*. </Callout>

**Theory:**
- An **operating system** (**OS**) is software that manages and handles the hardware and software resources of a system. It provides intrection between users of computers and computer hardware.
- An operating system is responsible for managing and controlling all the activities and sharing of computer resources.
- An operating system is a low-level software that includes all the basic functions like processor management, memory management, error detection, etc.

<FigureMdx lightUrl="operating-system-diagram" desc="Abstract view of a computer system."/>

<Callout>**Windows 10**</Callout>

**Hardware requirements**
- **Processor:** 1 GHz or faster processor
- **RAM:** 1 GB for 32-bit or 2 GB for 64-bit
- **Storage space:** 16 GB for 32-bit OS or 20 GB for 64-bit OS.
- **Display:** 800 x 6009 with WDDM driver

**Software requirements**
- **Graphics Card:** Direct X9 or later with WDDM 1.0 driver

<Callout>**UNIX**</Callout> 

**Hardware requirements**
- **Processor:** Minimum of 1 GHz processor
- **RAM:** Minimum of 1 GB RAM
- **Storage space:** Minimum of 10 GB free disk space

**Software requirements**
- UNIX-compatible operating system, such as Sun Solaris, IBM AIX, HP-UX, etc. 
- Compiler and development tools 
- X Window System for graphical user interface 
- Networking tools for network communication 

<Callout>**Linux**</Callout>

**Hardware Requirements:** 
- **Processor:** Minimum of 1 GHz processor 
- **RAM:** Minimum of 1 GB RAM (2 GB or more recommended for better performance) 
- **Storage space:** Minimum of 10 GB free disk space (20 GB or more recommended for better performance) 

**Software Requirements:** 
- Linux distribution, such as Ubuntu, Fedora, CentOS, Debian, etc. 
- Graphical user interface 
- Compiler and development tools 
- Networking tools for network communication 

<Callout>**Windows XP**</Callout> 

**Hardware Requirements:** 
- **Processor:** Minimum of Pentium 233 MHz processor (300 MHz or higher) 
- **RAM:** Minimum of 64 MB RAM (128 MB or higher) 
- **Storage space:** Minimum of 1.5 GB free disk space 

**Software Requirements:** 
- Windows XP operating system 
- DirectX 9 graphics device with WDDM driver (optional for graphical user interface) 
- Networking tools for network communication (optional) 

<Callout>**Windows 7/8**</Callout> 

**Hardware Requirements:** 
- **Processor:** Minimum of 1 GHz processor (1 GHz or higher) 
- **RAM:** Minimum of 1 GB RAM (2 GB or higher) 
- **Storage space:** Minimum of 16 GB free disk space (20 GB or higher)

**Software Requirements:**
- Windows 7 or Windows 8 operating system 
- DirectX 9 graphics device with WDDM 1.0 or higher driver (optional for graphical user interface) 
- Networking tools for network communication 

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-2">**Experiment 2**</Callout>
<Callout type="knowing">**Objective:** Execute various system calls. <ul><li>Process Management</li><li>File Management</li><li>Input/Output System Calls</li></ul></Callout>


**Process Management:** Process management uses certain system calls. They are explained below.
- **`fork()`:** system call is used to create a new process.
- **`exec()`:** system call is used to run a new program.
- **`wait()`:** system call is used to make the process to wait.
- **`exit()`:** system call is used to terminate the process.
- **`getpid()`:** system call is used to find the unique process id.
- **`getppid()`:** system call is used to find the parent process id.
- **`nice()`:** system call is used to bias the currently running process property.

*Example program for example of `fork()`*

```c title="fork.c"  showLineNumbers /fork()/#j
#include <stdio.h>
#include <sys/types.h>
main()
{
  int pid;
  pid = fork();
  if (pid == 0)
  {
    printf("id of the child process is=%d\n", getpid());
    printf("id of the parent process is=%d\n", getppid());
  }
  else
  {
    printf("id of the parent process is=%d\n", getpid());
    printf("id of the parent of parent process is=%d\n", getppid());
  }
}
```

**OUTPUT** 
``` terminal title="Terminal" showLineNumbers
id of the parent process is=8971
id of the parent of parent process is=8970
id of the child process is=8972
id of the parent process is=8971
```


**File Management:** There are four system calls for file management,
- **`open()`:** system call is used to know the file descriptor of user-created files. Since read and write use file descriptor as their 1st parameter so to know the file descriptor `open()`system call is used.
- **`read()`:** system call is used to read the content from the file. It can also be used to read the input from the keyboard by specifying the 0 as file descriptor.
- **`write()`:** system call is used to write the content to the file.
- **`close()`:** system call is used to close the opened file, it tells the operating system that you are done with the file and close the file.

*Example program for file management*

```c title="filemgt.c" showLineNumbers
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <stdio.h>
int main()
{
  int n, fd;
  char buff[50];
  printf("Enter text to write in the file:\n");
  n = read(0, buff, 50);
  fd = open("file", O_CREAT | O_RDWR, 0777);
  write(fd, buff, n);
  write(1, buff, n);
  int close(int fd);
  return 0;
}

```

**OUTPUT**

```terminal title="Terminal" showLineNumbers
Enter text to write in the file:
hi how r u?
hi how r u?
```

**Input/Output System Calls:** Basically there are total 5 types of I/O system calls:
- **`create()`:** Used to Create a new empty file.
- **`open()`:** Used to Open the file for reading, writing or both.
- **`close()`:** Tells the operating system you are done with a file descriptor and Close the filewhich pointed by fd.
- **`read()`:** From the file indicated by the file descriptor fd, the `read()` function reads bytesof input into the memory area indicated by buf. 
- **`write()`:** Writes bytes from buf to the file or socket associated with fd.

*Example program for Input/output System Calls*

``` c title="input_output.c" showLineNumbers
#include <stdio.h>
#include <unistd.h>

int main()
{
  char buffer[100];
  int n;

  // Read input from the user
  write(STDOUT_FILENO, "Enter a message: ", 17);
  n = read(STDIN_FILENO, buffer, 100);

  // Write the input back to the user
  write(STDOUT_FILENO, "You entered: ", 13);
  write(STDOUT_FILENO, buffer, n);

  return 0;
}
```
**OUTPUT**
``` terminal title="Terminal" showLineNumbers
Enter a message: helo
You entered: helo
```


<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-3">**Experiment 3**</Callout>
<Callout type="knowing">**Objective:** Implement CPU Scheduling Policies: <ul><li>SJF</li><li>Priority</li><li>FCFS</li><li>Multi-level Queue</li></ul></Callout>

```c title="FirstComeFirstSearch.c" showLineNumbers
#include <stdio.h>

int main()

{
  int n, bt[30], wait_t[30], turn_ar_t[30], av_wt_t = 0, avturn_ar_t = 0, i, j;
  // the maximum process that be used to calculate is specified.
  printf("Please enter the total number of processes(maximum 30): "); 
  scanf("%d", &n);

  printf("\nEnter The Process Burst Timen");
  for (i = 0; i < n; i++) // burst time for every process will be taken as input
  {
    printf("P[%d]:", i + 1);
    scanf("%d", &bt[i]);
  }

  wait_t[0] = 0;

  for (i = 1; i < n; i++)
  {
    wait_t[i] = 0;
    for (j = 0; j < i; j++)
      wait_t[i] += bt[j];
  }

  printf("\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time");

  for (i = 0; i < n; i++)
  {
    turn_ar_t[i] = bt[i] + wait_t[i];
    av_wt_t += wait_t[i];
    avturn_ar_t += turn_ar_t[i];
    printf("\nP[%d]\t\t%d\t\t\t%d\t\t\t\t%d", i + 1, bt[i], wait_t[i], turn_ar_t[i]);
  }

  av_wt_t /= i;
  avturn_ar_t /= i; // average calculation is done here
  printf("\nAverage Waiting Time=%d", av_wt_t);
  printf("\nAverage Turnaround Time=%d", avturn_ar_t);

  return 0;
}
```
```makefile title="Output"
Please enter the total number of processes(maximum 30): 5

Enter The Process Burst TimenP[1]:4      
P[2]:6
P[3]:2
P[4]:1
P[5]:9

Process      Burst Time      Waiting Time     Turnaround Time
P[1]            4                  4
P[2]            6                  10
P[3]            2                  10             12       
P[4]            1                  12             13       
P[5]            9                  13             22       
Average Waiting Time=7
Average Turnaround Time=12
```

```c title="SortestJobFirst.c" showLineNumbers
#include <stdio.h>
void main()
{
  int bt[20], p[20], wt[20], tat[20], i, j, n, total = 0, pos, temp; 
  // bt-Burst Time // wt-Waiting Time  //  tat-Turn Around Time  //pos-position
  float avg_wt, avg_tat;

  printf("Enter number of process:");
  scanf("%d", &n);

  printf("\nEnter Burst Time:\n");
  for (i = 0; i < n; i++)
  {
    printf("p%d:", i + 1);
    scanf("%d", &bt[i]);
    p[i] = i + 1; // contains process number
  }

  // sorting burst time in ascending order using selection sort
  for (i = 0; i < n; i++)
  {
    pos = i;
    for (j = i + 1; j < n; j++)
    {
      if (bt[j] < bt[pos])
        pos = j;
    }

    temp = bt[i];
    bt[i] = bt[pos];
    bt[pos] = temp;
    temp = p[i];
    p[i] = p[pos];
    p[pos] = temp;
  }

  wt[0] = 0; // waiting time for first process will be zero

  // calculate waiting time
  for (i = 1; i < n; i++)
  {
    wt[i] = 0;
    for (j = 0; j < i; j++)
      wt[i] += bt[j];
    total += wt[i];
  }
  avg_wt = (float)total / n; // average waiting time
  total = 0;

  printf("\nProcess\t    Burst Time    \tWaiting Time\tTurnaround Time");
  for (i = 0; i < n; i++)
  {
    tat[i] = bt[i] + wt[i]; // calculate turnaround time
    total += tat[i];
    printf("\np%d\t\t  %d\t\t    %d\t\t\t%d", p[i], bt[i], wt[i], tat[i]);
  }
  avg_tat = (float)total / n; // average turnaround time
  printf("\n\nAverage Waiting Time=%f", avg_wt);
  printf("\nAverage Turnaround Time=%f\n", avg_tat);
}
```

```makefile title="Output" 
Enter number of process:6

Enter Burst Time:
p1:1
p2:5
p3:9
p4:7
p5:4
p6:8

Process     Burst Time     Waiting Time     Turnaround Time
p1                1            0                   1
p5                4            1                   5
p2                5            5                   10
p4                7            10                  17
p6                8            17                  25
p3                9            25                  34

Average Waiting Time=9.666667
Average Turnaround Time=15.333333  
```

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-4">**Experiment 4**</Callout>
<Callout type="knowing">**Objective:** Implement file storage allocation technique: <ul><li>Contiguous (using array)</li><li>Linked-list (using linked-list)</li><li>Indirect allocation (indexing)</li></ul></Callout>

<Callout type="warning" txCenter="true" breakBefore="true" id="experiment-5">**Experiment 5**</Callout>
<Callout type="knowing">**Objective:** Implementation of contiguous allocation techniques: <ul><li>Worst-Fit</li><li>Best-Fit</li><li>First-Fit</li></ul></Callout>


**See Also**

- [Operating System](/learn/operating-system/)